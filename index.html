<!-- Given a  2D array, , an hourglass is a subset of values with indices falling in the following pattern:

a b c  
  d  
e f g

There are 16 hourglasses in a 6 X 6 array. The hourglassSum is the sum of the values in an hourglass.
 Calculate the hourglass sum for every hourglass in arr, then print the maximum hourglass sum.

Example:

-9 -9 -9  1 1 1 
 0 -9  0  4 3 2
-9 -9 -9  1 2 3
 0  0  8  6 6 0
 0  0  0 -2 0 0
 0  0  1  2 4 0

 The  hourglass sums are:

-63, -34, -9, 12, 
-10,   0, 28, 23, 
-27, -11, -2, 10, 
  9,  17, 25, 18

  The highest hourglass sum is 28 from the hourglass beginning at row , column 2 :

0 4 3
  1
8 6 6 -->
const hourGlassSum = arr => {
  let maxSum =-Infinity;

  for (let i = 0; i < arr.length - 2; i++){
    for (let j = 0; j < arr[i].length - 2; j++){
      let sum =
      arr[i][j] + arr[i][j + 1] + arr[i][j + 2] +
      arr[i + 1][j + 1] +
      arr[i + 2][j] + arr[i + 2][j + 1] + arr[i + 2][j + 2];
      maxSum = Math.max(sum, maxSum); 
    }
  }
  return maxSum
};

<!-- Check if parentheses string is valid.
Example: "()[]{}" → true, "(]" → false -->
const isValidParenthesis = s => {
  let stack = [];
  let mapping = { ')': '(', ']': '[', '}': '{'};

  for (let char of s){
    if (mapping[char]){
      if(stack.pop() !== mapping[char]){
        return false;
      }
    } else {
      stack.push(char);
    }
  }
  return stack.length === 0;
};

<!-- Problem: Count ways to climb n stairs (1 or 2 steps). -->
<!-- Example: n=3 → 3 ways (1+1+1, 1+2, 2+1) -->
const climbStairs = (n) => {
  if (n <= 2) return n;
 
  let first = 1, second = 2;
  for (let i = 3; i <= n; i++) {
      const third = first + second;
      first = second;
      second = third;
  }
  return second;
  <!-- Problem: Two Sum -->
  <!-- Difficulty: Easy -->
  <!--  -->
  <!-- Problem Statement: -->
  <!-- Given an array of integers nums and an integer target, return the indices of the two numbers such that they add up to target. -->
  <!--  -->
  <!-- You may assume that each input would have exactly one solution, and you may not use the same element twice. -->
  <!--  -->
  <!-- You can return the answer in any order. -->

  const twoSum = (nums, target) => {
    let map = new Map();

    for (let i = 0; i < nums.length; i++){
      const complement = target - nums[i];

      if(map.has(complement)){
        return [map.get(complement), i];
      }
      map.set(nums[i], i);
    }
      return [];
  }

  <!-- Problem: Return level order traversal of binary tree.
  Example: [3,9,20,null,null,15,7] → [[3],[9,20],[15,7]]
  
  Pattern: ______
  Time: ______
  Space: ______ -->

  const treeTraversal = root => {
    if(!root) return [];
  
    let result = [];
    let queue = [root];
  
    while(queue.length > 0){
      let levelSize = queue.length;
      let currentLevel = [];
  
      for(let i = 0; i < levelSize; i++){
        let node = queue.shift();           
        currentLevel.push(node.val);
  
        if(node.left){
          queue.push(node.left);
        }
        if(node.right){
          queue.push(node.right);
        }
      }
      result.push(currentLevel);
    }
    return result;
  };

  <!-- Find maximum sum of contiguous subarray of size k.
  Example: [2,1,5,1,3,2], k=3 → 9 ([5,1,3]) -->

  const maxSubArr = (arr ,k) => {
    let maxSum = -Infinity;
    let windowSum = 0;
    let start = 0;
  
    for(let end = 0; end <= arr.length - 1; end++){
      windowSum += arr[end];
  
      if(end >= k - 1){
        maxSum = Math.max(maxSum, windowSum);
        windowSum -= arr[start];
        start ++;
      }
    }
    return maxSum;
  }

  const levelTraversal = root => {
    if(!root) return [];

    let result = [];
    let queue = [root];

    while(queue.length > 0){
      let levelSize = queue.length;
      let currentLevel = [];

      for (let i = 0; i < levelSize; i++){
        let node = queue.shift();
        currentLevel.push(node.val);
      
        if(node.left){
          queue.push(node.left);
        }
        if(node.right){
          queue.push(node.right); 
        }
      }
      result.push(currentLevel);
    }
    return result;
  };
<!-- check the maximum depth of a binary tree -->
  const maxDepth = root => {
    if(!root) return [];

    let leftDepth = maxDepth(root.left);
    let rightDepth = maxDepth(root.right);

   return Math.max(leftDepth, rightDepth) + 1;
  }

  function levelOrderTraversale(root){
    if(!root) return [];

    const result = [];
    const queue = [root];

    while(queue.length > 0){
      let levelSize = queue.length;
      let currentLevel = [];

      for(let i = 0; i < levelSize; i++){
        let node = queue.shift();
        currentLevel.push(node.val);

        if(node.left){
          queue.push(node.left);
        }
        if(node.right){
          queue.push(node.right);
        }
      }
      result.push(currentLevel);
    }
    return result;
  };

  <!-- Problem: Detect cycle in linked list. -->

   const hasCycle = head => {
    if(!head || !head.next) return false;

    let slow = head; 
    let fast = head;

    while(fast && fast.next){
      slow = slow.next;
      fast = fast.next.next;

      if(slow === fast) return true;
    }
    return false;
   }

   <!-- Problem: Search target in sorted array.
Example: [-1,0,3,5,9,12], target=9 → 4 -->

const searchTarget = (arr, target) => {
  let left = 0, right = arr.length - 1;
  
  while(left <= right) {
    const mid = Math.floor((left + right) / 2);
    if(arr[mid] === target) {
      return mid;
    } else if(arr[mid] < target) {
      left = mid + 1;
    } else if(arr[mid] > target){
      right = mid - 1;
    }
  }
  return -1;
}
<!-- Problem: Merge overlapping intervals.
Example: [[1,3],[2,6],[8,10]] → [[1,6],[8,10]] -->
const mergeIntervals = (intervals) => {
  intervals.sort((a, b) => a[0] - b[0]);
  const merged = [intervals[0]];
 
  for (let i = 1; i < intervals.length; i++) {
      const last = merged[merged.length - 1];
      const current = intervals[i];
     
      if (current[0] <= last[1]) {
          last[1] = Math.max(last[1], current[1]);
      } else {
          merged.push(current);
      }
  }
  return merged;
};

<!-- Find maximum depth of binary tree.
Example: [3,9,20,null,null,15,7] → 3 -->

function maxDepth(root){
  if(!root) return 0;

  const leftDepth = maxDepth(root.left);
  const rightDepth = maxDepth(root.right);

  return Math.max(leftDepth, rightDepth) + 1;
};
<!-- Given an integer array nums, return an array output such that output[i] 
 is equal to the product of all the elements of nums except nums[i]. -->

const prodExceptNum = (arr) => {
  const result = new Array(arr.length).fill(1);
  let prefix = 1;
  let suffix = 1;

  for (let i = 0; i < arr.length; i++) {
    result[i] *= prefix;
    prefix *= arr[i];
  }

  for (let i = arr.length - 1; i >= 0; i--) {
    result[i] *= suffix;
    suffix *= arr[i];
  }

  return result;
};

